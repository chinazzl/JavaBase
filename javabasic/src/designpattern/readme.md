设计模式
1. 工厂模式 factory pattern
2. 单例模式 6种 
3. 原型模式：prototype: 原型模式主要适用于以下应用场景。
    （1）创建对象成本较大（例如，初始化时间长，占用CPU太多，或者占用网络资源太多等），需要优化资源。
    （2）创建一个对象需要烦琐的数据准备或访问权限等，需要提高性能或者提高安全性。
    （3）系统中大量使用该类对象，且各个调用者都需要给它的属性重新赋值。在Spring中，
        原型模式应用得非常广泛，例如scope="prototype"、JSON.parseObject（），都是原型模式的具体应用。
4. 代理模式：
    1. 静态代理
    2. 动态代理 ：
        CGLib和JDK动态代理对比：
            1. JDK动态代理实现了被代理对象的接口，CGLib代理继承了被代理对象
            2. JDK动态代理和CGLib代理都在运行期生成字节码，JDK胴体代理直接写Class字节码，CGLib代理使用ASM框架写Class字节码。CGLib代理实现更复杂，
               生成代理类比JDK动态代理效率低。
            3. JDK动态代理调用代理方法是通过反射机制调用的，CGLib代理是通过FastClass机制直接调用方法的，CGLib代理的执行效率更高。
5. 委派模式（Delegate Pattern）：基本作用是负责任务的调用和分配，可以看作一种特殊情况下的静态的全权代理。SpringMVC中的Dispatcher Servlet就用到了委派模式。    
6. 策略模式（Strategy Pattern）：是指定义了算法家族并分别封装起来，让它们之间可以互相替换，此模式使得算法的变化不会影响使用算法的用户。
    应用场景：
        1. 系统中有很多类，而它们的区别仅仅在于行为不同
        2. 一个系统需要动态地在几种算法中选择一种。   
7. 模板模式：模板方法模式（Template Method Pattern），是指定义一个算法框架，并允许子类为一个或者多个步骤提供实现。适用于以下场景：
    1. 一次性实现一个算法的不变部分，并将可变的行为留给子类来实现
    2. 各子类中公共的行为被提取出来并集中到一个公共的父类中，从而避免代码 重复。
8. 适配器模式： (Adapter Pattern) 是指将一个类的接口转换成用户期望的另一个接口，使原本接口不兼容的类可以一起工作，属于结构型设计模式。
9. 装饰者模式：（Decorator pattern） 在不改变原有对象的基础上，将功能附加到对象上，提供了比继承更有弹性的方案，适用以下场景“
    a. 扩展一个类的功能或给一个类添加附加职责
    b. 动态给一个对象添加功能，这些功能可以再动态地撤销
10. 观察者模式：（observation pattern）也叫发布/订阅模式 ，定义了对象之间的一对多依赖，让多个观察者对象同时监听一个主体对象，当主题对象发生变化时，它的所有依赖者（观察者）都会
    收到通知并更新。
11. 责任链模式：例如使用多重校验时可进行使用。