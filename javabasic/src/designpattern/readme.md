设计模式
1. 工厂模式 factory pattern
2. 单例模式 6种 
3. 原型模式：prototype: 原型模式主要适用于以下应用场景。
    （1）创建对象成本较大（例如，初始化时间长，占用CPU太多，或者占用网络资源太多等），需要优化资源。
    （2）创建一个对象需要烦琐的数据准备或访问权限等，需要提高性能或者提高安全性。
    （3）系统中大量使用该类对象，且各个调用者都需要给它的属性重新赋值。在Spring中，
        原型模式应用得非常广泛，例如scope="prototype"、JSON.parseObject（），都是原型模式的具体应用。
4. 代理模式：
    1. 静态代理
    2. 动态代理 ：
        CGLib和JDK动态代理对比：
            1. JDK动态代理实现了被代理对象的接口，CGLib代理继承了被代理对象
            2. JDK动态代理和CGLib代理都在运行期生成字节码，JDK胴体代理直接写Class字节码，CGLib代理使用ASM框架写Class字节码。CGLib代理实现更复杂，
               生成代理类比JDK动态代理效率低。
            3. JDK动态代理调用代理方法是通过反射机制调用的，CGLib代理是通过FastClass机制直接调用方法的，CGLib代理的执行效率更高。
5. 委派模式（Delegate Pattern）：基本作用是负责任务的调用和分配，可以看作一种特殊情况下的静态的全权代理。SpringMVC中的Dispatcher Servlet就用到了委派模式。    
6. 策略模式（Strategy Pattern）：是指定义了算法家族并分别封装起来，让它们之间可以互相替换，此模式使得算法的变化不会影响使用算法的用户。
    应用场景：
        1. 系统中有很多类，而它们的区别仅仅在于行为不同
        2. 一个系统需要动态地在几种算法中选择一种。   
7. 模板模式：模板方法模式（Template Method Pattern），是指定义一个算法框架，并允许子类为一个或者多个步骤提供实现。适用于以下场景：
    1. 一次性实现一个算法的不变部分，并将可变的行为留给子类来实现
    2. 各子类中公共的行为被提取出来并集中到一个公共的父类中，从而避免代码 重复。